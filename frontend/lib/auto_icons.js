import { faChevronRight } from '@fortawesome/free-solid-svg-icons/faChevronRight';
import { icon } from '@fortawesome/fontawesome-svg-core';

const cache = {};
function buildIcon(iconData) {
  // Determine a unique cache ID for either FontAwesome icons, or the raw image
  // icons.
  const cacheId = `${iconData.prefix}-${iconData.iconName}`;
  if (!cache[cacheId]) {
    // Handle imported FontAwesome SVG icons.
    const faIcon = icon(iconData, { classes: ['template-auto-icon'] });
    cache[cacheId] = faIcon.node[0];
  }

  return cache[cacheId].cloneNode(true);
}

// Add the icon, but wrap a span around the last word in the text and the icon
// so that they can always be kept on the same line together (so the icon
// doesn't end up on its own on a new line).
//
// There are other slightly simpler ways (like a final span around a `&nbsp;`
// and the icon), but those tend to require more explicit CSS styling (eg,
// since the `&nbsp;` may lead to underlining the space, but not the icon,
// which is solvable, but requires additional wrapper elements or explicit CSS
// rules), so going with this approach since it should make the CSS rules apply
// more intuitively.
function addIconNowrapLastWord(el, icon) {
  // Recursively find all of the text nodes inside (this accounts for this
  // element potentially including more nested HTML markup by just focusing on
  // the text nodes).
  const treeWalker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);
  const textNodes = [];
  while (treeWalker.nextNode()) {
    textNodes.push(treeWalker.currentNode);
  }

  // If there is no text, then we won't add an icon.
  if (textNodes.length === 0) {
    return;
  }

  // Grab the last text node and extract the text.
  const lastTextNode = textNodes[textNodes.length - 1];
  const lastParentEl = lastTextNode.parentNode;
  const lastText = lastTextNode.nodeValue

  // Split the text node into 2 text nodes based on the position of the last
  // space (or if there are no spaces, then the last text node is the last
  // word).
  const lastSpaceIndex = lastText.lastIndexOf(' ');
  const lastWordTextNode = (lastSpaceIndex === -1) ? lastTextNode : lastTextNode.splitText(lastSpaceIndex);

  // Create a span element to wrap the last word with the new icon we're
  // adding. This way the two can always be kept together with a CSS
  // `white-space: nowrap` setting.
  const nowrapEl = document.createElement('span')
  nowrapEl.className = 'text-nowrap template-auto-icon-nowrap';
  nowrapEl.appendChild(lastWordTextNode);
  nowrapEl.appendChild(buildIcon(icon));

  // Since the last word text node was moved into a new element, we can now
  // append the combined nowrap el that contains the last word and the icon
  // back into the DOM to replace the last word that was moved.
  lastParentEl.appendChild(nowrapEl);
}

function addHeaderLinkIcon(headerEl) {
  addIconNowrapLastWord(headerEl, faChevronRight);
}

function appendNodeMatches(matches, selector, node) {
  if (node instanceof Element) {
    if (node.matches(selector)) {
      matches.push(node);
    }

    matches.push.apply(matches, node.querySelectorAll(selector));
  }
}

function appendTreeMatches(matches, selector, nodes) {
  for (let i = 0, len = nodes.length; i < len; i++) {
    appendNodeMatches(matches, selector, nodes[i]);
  }
}

// Use the MutationObserver API to insert icons into certain selectors (eg,
// file links or linked headers). By using the MutationObserver (rather than
// just executing this logic on document ready), this ensures that dynamic
// content on the page will be updated appropriately for JavaScript-heavy apps
// (eg, if a file download link is generated by JavaScript and injected onto
// the page after load).
//
// Ideally, we could handle all this via CSS pseudo selectors, but since we're
// trying to use FontAwesome SVG icons, this gets tricky to handle with just
// pseudo-CSS selectors and inline SVGs. FontAwesome does support
// pseudo-selectors
// (https://fontawesome.com/how-to-use/on-the-web/advanced/css-pseudo-elements),
// but when using the SVG icons, this can become very non-performant
// (https://docs.fontawesome.com/apis/javascript/configuration#searchpseudoelements).
// This approach here uses the same basic strategy as FontAwesome's normal
// JavaScript/SVG library, which also utilizes the MutationObserver
// (https://fontawesome.com/how-to-use/with-the-api/methods/dom-watch), so it
// should be performant (since the pseudo-selectors don't have to be parsed and
// observed).
function observe(selector, observerOptions, callback) {
  // Keep track of which nodes have already had the callback called, so we
  // don't execute the callback multiple times per node.
  const nodeCallbackCalled = [];
  const matchesCallback = function(matches) {
    for (let i = 0, len = matches.length; i < len; i++) {
      const match = matches[i];
      if (nodeCallbackCalled.indexOf(match) === -1) {
        callback(matches[i]);
        nodeCallbackCalled.push(match);
      }
    }
  }

  // Check for any elements already on the page.
  matchesCallback(document.querySelectorAll(selector));

  // Setup an observer to track any future elements matching our selector that
  // get added to the page.
  const observer = new MutationObserver(function(mutations) {
    const matches = [];
    for (let i = 0, len = mutations.length; i < len; i++) {
      const mutation = mutations[i];
      if (mutation.type === 'childList') {
        appendTreeMatches(matches, selector, mutation.addedNodes);
      } else if (mutation.type === 'attributes') {
        appendNodeMatches(matches, selector, mutation.target);
      }
    }

    matchesCallback(matches);
  });
  observer.observe(document, observerOptions);
}

// Keep selectors in sync with selectors in
// `frontend/stylesheets/_type.scss`, since we don't want underline on header
// links that also have this icon to serve as a link indicator.
observe('h1 a[href]:not(.skip-template-auto-icon), h2 a[href]:not(.skip-template-auto-icon), h3 a[href]:not(.skip-template-auto-icon), h4 a[href]:not(.skip-template-auto-icon), h5 a[href]:not(.skip-template-auto-icon), h6 a[href]:not(.skip-template-auto-icon)', {
  childList: true,
  subtree: true,
}, addHeaderLinkIcon);
