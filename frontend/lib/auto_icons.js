import { faChevronRight } from '@fortawesome/free-solid-svg-icons/faChevronRight';
import { icon } from '@fortawesome/fontawesome-svg-core';

const cache = {};
function buildIcon(iconData, alt) {
  // Determine a unique cache ID for either FontAwesome icons, or the raw image
  // icons.
  const cacheId = `${iconData.prefix}-${iconData.iconName}`;
  if (!cache[cacheId]) {
    // Handle imported FontAwesome SVG icons.
    const faIcon = icon(iconData);

    const wrapperEl = document.createElement('span');
    wrapperEl.className = 'template-auto-icon';
    wrapperEl.appendChild(faIcon.node[0]);

    cache[cacheId] = wrapperEl;
  }

  return cache[cacheId].cloneNode(true);
}

function addHeaderLinkIcon(headerEl) {
  headerEl.appendChild(buildIcon(faChevronRight));
}

function appendNodeMatches(matches, selector, node) {
  if (node instanceof Element) {
    if (node.matches(selector)) {
      matches.push(node);
    }

    matches.push.apply(matches, node.querySelectorAll(selector));
  }
}

function appendTreeMatches(matches, selector, nodes) {
  for (let i = 0, len = nodes.length; i < len; i++) {
    appendNodeMatches(matches, selector, nodes[i]);
  }
}

// Use the MutationObserver API to insert icons into certain selectors (eg,
// file links or linked headers). By using the MutationObserver (rather than
// just executing this logic on document ready), this ensures that dynamic
// content on the page will be updated appropriately for JavaScript-heavy apps
// (eg, if a file download link is generated by JavaScript and injected onto
// the page after load).
//
// Ideally, we could handle all this via CSS pseudo selectors, but since we're
// trying to use FontAwesome SVG icons, this gets tricky to handle with just
// pseudo-CSS selectors and inline SVGs. FontAwesome does support
// pseudo-selectors
// (https://fontawesome.com/how-to-use/on-the-web/advanced/css-pseudo-elements),
// but when using the SVG icons, this can become very non-performant
// (https://docs.fontawesome.com/apis/javascript/configuration#searchpseudoelements).
// This approach here uses the same basic strategy as FontAwesome's normal
// JavaScript/SVG library, which also utilizes the MutationObserver
// (https://fontawesome.com/how-to-use/with-the-api/methods/dom-watch), so it
// should be performant (since the pseudo-selectors don't have to be parsed and
// observed).
function observe(selector, observerOptions, callback) {
  // Keep track of which nodes have already had the callback called, so we
  // don't execute the callback multiple times per node.
  const nodeCallbackCalled = [];
  const matchesCallback = function(matches) {
    for (let i = 0, len = matches.length; i < len; i++) {
      const match = matches[i];
      if (nodeCallbackCalled.indexOf(match) === -1) {
        callback(matches[i]);
        nodeCallbackCalled.push(match);
      }
    }
  }

  // Check for any elements already on the page.
  matchesCallback(document.querySelectorAll(selector));

  // Setup an observer to track any future elements matching our selector that
  // get added to the page.
  const observer = new MutationObserver(function(mutations) {
    const matches = [];
    for (let i = 0, len = mutations.length; i < len; i++) {
      const mutation = mutations[i];
      if (mutation.type === 'childList') {
        appendTreeMatches(matches, selector, mutation.addedNodes);
      } else if (mutation.type === 'attributes') {
        appendNodeMatches(matches, selector, mutation.target);
      }
    }

    matchesCallback(matches);
  });
  observer.observe(document, observerOptions);
}

// Keep selectors in sync with selectors in
// `frontend/stylesheets/_type.scss`, since we don't want underline on header
// links that also have this icon to serve as a link indicator.
observe('h1 a[href]:not(.skip-template-auto-icon), h2 a[href]:not(.skip-template-auto-icon), h3 a[href]:not(.skip-template-auto-icon), h4 a[href]:not(.skip-template-auto-icon), h5 a[href]:not(.skip-template-auto-icon), h6 a[href]:not(.skip-template-auto-icon)', {
  childList: true,
  subtree: true,
}, addHeaderLinkIcon);
