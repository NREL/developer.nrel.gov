{"version":3,"file":"contact-CNA6AOEl.js","sources":["../../../../node_modules/.pnpm/a11y-dialog@8.1.3/node_modules/a11y-dialog/dist/a11y-dialog.esm.js","../../../../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js","../../../../node_modules/.pnpm/form-serialize@0.7.2/node_modules/form-serialize/index.js","../../../../frontend/entrypoints/contact.js"],"sourcesContent":["const not = {\n  inert: ':not([inert]):not([inert] *)',\n  negTabIndex: ':not([tabindex^=\"-\"])',\n  disabled: ':not(:disabled)',\n};\n\nvar focusableSelectors = [\n  `a[href]${not.inert}${not.negTabIndex}`,\n  `area[href]${not.inert}${not.negTabIndex}`,\n  `input:not([type=\"hidden\"]):not([type=\"radio\"])${not.inert}${not.negTabIndex}${not.disabled}`,\n  `input[type=\"radio\"]${not.inert}${not.negTabIndex}${not.disabled}`,\n  `select${not.inert}${not.negTabIndex}${not.disabled}`,\n  `textarea${not.inert}${not.negTabIndex}${not.disabled}`,\n  `button${not.inert}${not.negTabIndex}${not.disabled}`,\n  `details${not.inert} > summary:first-of-type${not.negTabIndex}`,\n  // Discard until Firefox supports `:has()`\n  // See: https://github.com/KittyGiraudel/focusable-selectors/issues/12\n  // `details:not(:has(> summary))${not.inert}${not.negTabIndex}`,\n  `iframe${not.inert}${not.negTabIndex}`,\n  `audio[controls]${not.inert}${not.negTabIndex}`,\n  `video[controls]${not.inert}${not.negTabIndex}`,\n  `[contenteditable]${not.inert}${not.negTabIndex}`,\n  `[tabindex]${not.inert}${not.negTabIndex}`,\n];\n\n/**\n * Set the focus to the first element with `autofocus` with the element or the\n * element itself.\n */\nfunction focus(el) {\n    (el.querySelector('[autofocus]') || el).focus();\n}\n/**\n * Get the first and last focusable elements within a given element.\n */\nfunction getFocusableEdges(el) {\n    // Check for a focusable element within the subtree of the given element.\n    const firstEl = findFocusableEl(el, true);\n    // Only if we find the first element do we need to look for the last one. If\n    // there’s no last element, we set `lastEl` as a reference to `firstEl` so\n    // that the returned array is still always of length 2.\n    const lastEl = firstEl ? findFocusableEl(el, false) || firstEl : null;\n    return [firstEl, lastEl];\n}\n/**\n * Find the first focusable element inside the given element if `forward` is\n * truthy or the last focusable element otherwise.\n */\nfunction findFocusableEl(el, forward) {\n    // If we’re walking forward, check if this element is focusable, and return it\n    // immediately if it is.\n    if (forward && isFocusable(el))\n        return el;\n    // We should only search the subtree of this element if it can have focusable\n    // children.\n    if (canHaveFocusableChildren(el)) {\n        // Start walking the DOM tree, looking for focusable elements.\n        // Case 1: If this element has a shadow root, search it recursively.\n        if (el.shadowRoot) {\n            // Descend into this subtree.\n            let next = getNextChildEl(el.shadowRoot, forward);\n            // Traverse the siblings, searching the subtree of each one for focusable\n            // elements.\n            while (next) {\n                const focusableEl = findFocusableEl(next, forward);\n                if (focusableEl)\n                    return focusableEl;\n                next = getNextSiblingEl(next, forward);\n            }\n        }\n        // Case 2: If this element is a slot for a Custom Element, search its\n        // assigned elements recursively.\n        else if (el.localName === 'slot') {\n            const assignedElements = el.assignedElements({\n                flatten: true,\n            });\n            if (!forward)\n                assignedElements.reverse();\n            for (const assignedElement of assignedElements) {\n                const focusableEl = findFocusableEl(assignedElement, forward);\n                if (focusableEl)\n                    return focusableEl;\n            }\n        }\n        // Case 3: this is a regular Light DOM element. Search its subtree.\n        else {\n            // Descend into this subtree.\n            let next = getNextChildEl(el, forward);\n            // Traverse siblings, searching the subtree of each one\n            // for focusable elements.\n            while (next) {\n                const focusableEl = findFocusableEl(next, forward);\n                if (focusableEl)\n                    return focusableEl;\n                next = getNextSiblingEl(next, forward);\n            }\n        }\n    }\n    // If we’re walking backward, we want to check the element’s entire subtree\n    // before checking the element itself. If this element is focusable, return\n    // it.\n    if (!forward && isFocusable(el))\n        return el;\n    return null;\n}\nfunction getNextChildEl(el, forward) {\n    return forward ? el.firstElementChild : el.lastElementChild;\n}\nfunction getNextSiblingEl(el, forward) {\n    return forward ? el.nextElementSibling : el.previousElementSibling;\n}\n/**\n * Determine if an element is hidden from the user.\n */\nconst isHidden = (el) => {\n    // Browsers hide all non-<summary> descendants of closed <details> elements\n    // from user interaction, but those non-<summary> elements may still match our\n    // focusable-selectors and may still have dimensions, so we need a special\n    // case to ignore them.\n    if (el.matches('details:not([open]) *') &&\n        !el.matches('details>summary:first-of-type'))\n        return true;\n    // If this element has no painted dimensions, it's hidden.\n    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\n};\n/**\n * Determine if an element is focusable and has user-visible painted dimensions.\n */\nconst isFocusable = (el) => {\n    // A shadow host that delegates focus will never directly receive focus,\n    // even with `tabindex=0`. Consider our <fancy-button> custom element, which\n    // delegates focus to its shadow button:\n    //\n    // <fancy-button tabindex=\"0\">\n    //  #shadow-root\n    //  <button><slot></slot></button>\n    // </fancy-button>\n    //\n    // The browser acts as as if there is only one focusable element – the shadow\n    // button. Our library should behave the same way.\n    if (el.shadowRoot?.delegatesFocus)\n        return false;\n    return el.matches(focusableSelectors.join(',')) && !isHidden(el);\n};\n/**\n * Determine if an element can have focusable children. Useful for bailing out\n * early when walking the DOM tree.\n * @example\n * This div is inert, so none of its children can be focused, even though they\n * meet our criteria for what is focusable. Once we check the div, we can skip\n * the rest of the subtree.\n * ```html\n * <div inert>\n *   <button>Button</button>\n *   <a href=\"#\">Link</a>\n * </div>\n * ```\n */\nfunction canHaveFocusableChildren(el) {\n    // The browser will never send focus into a Shadow DOM if the host element\n    // has a negative tabindex. This applies to both slotted Light DOM Shadow DOM\n    // children\n    if (el.shadowRoot && el.getAttribute('tabindex') === '-1')\n        return false;\n    // Elemments matching this selector are either hidden entirely from the user,\n    // or are visible but unavailable for interaction. Their descentants can never\n    // receive focus.\n    return !el.matches(':disabled,[hidden],[inert]');\n}\n/**\n * Get the active element, accounting for Shadow DOM subtrees.\n * @author Cory LaViska\n * @see: https://www.abeautifulsite.net/posts/finding-the-active-element-in-a-shadow-root/\n */\nfunction getActiveEl(root = document) {\n    const activeEl = root.activeElement;\n    if (!activeEl)\n        return null;\n    // If there’s a shadow root, recursively find the active element within it.\n    // If the recursive call returns null, return the active element\n    // of the top-level Document.\n    if (activeEl.shadowRoot)\n        return getActiveEl(activeEl.shadowRoot) || document.activeElement;\n    // If not, we can just return the active element\n    return activeEl;\n}\n/**\n * Trap the focus inside the given element\n */\nfunction trapTabKey(el, event) {\n    const [firstFocusableEl, lastFocusableEl] = getFocusableEdges(el);\n    // If there are no focusable children in the dialog, prevent the user from\n    // tabbing out of it\n    if (!firstFocusableEl)\n        return event.preventDefault();\n    const activeEl = getActiveEl();\n    // If the SHIFT key is pressed while tabbing (moving backwards) and the\n    // currently focused item is the first one, move the focus to the last\n    // focusable item from the dialog element\n    if (event.shiftKey && activeEl === firstFocusableEl) {\n        // @ts-ignore: we know that `lastFocusableEl` is not null here\n        lastFocusableEl.focus();\n        event.preventDefault();\n    }\n    // If the SHIFT key is not pressed (moving forwards) and the currently focused\n    // item is the last one, move the focus to the first focusable item from the\n    // dialog element\n    else if (!event.shiftKey && activeEl === lastFocusableEl) {\n        firstFocusableEl.focus();\n        event.preventDefault();\n    }\n}\n/**\n * Find the closest element to the given element matching the given selector,\n * accounting for Shadow DOM subtrees.\n * @author Louis St-Amour\n * @see: https://stackoverflow.com/a/56105394\n */\nfunction closest(selector, base) {\n    function from(el) {\n        if (!el || el === document || el === window)\n            return null;\n        // Reading the `assignedSlot` property from the element (as suggested by the\n        // aforementioned StackOverflow answer) is not enough, because it does not\n        // take into consideration elements nested deeply within a <slot>. For these\n        // elements, the `assignedSlot` property is `null` as it is only specified\n        // for top-level elements within a <slot>. To still find the closest <slot>,\n        // we walk up the tree looking for the `assignedSlot` property.\n        const slot = findAssignedSlot(el);\n        if (slot)\n            el = slot;\n        return (el.closest(selector) ||\n            from(el.getRootNode().host));\n    }\n    return from(base);\n}\nfunction findAssignedSlot(node) {\n    return (node.assignedSlot ||\n        (node.parentNode ? findAssignedSlot(node.parentNode) : null));\n}\n\nconst SCOPE = 'data-a11y-dialog';\nclass A11yDialog {\n    $el;\n    id;\n    previouslyFocused;\n    shown;\n    constructor(element) {\n        this.$el = element;\n        this.id = this.$el.getAttribute(SCOPE) || this.$el.id;\n        this.previouslyFocused = null;\n        this.shown = false;\n        this.maintainFocus = this.maintainFocus.bind(this);\n        this.bindKeypress = this.bindKeypress.bind(this);\n        this.handleTriggerClicks = this.handleTriggerClicks.bind(this);\n        this.show = this.show.bind(this);\n        this.hide = this.hide.bind(this);\n        this.$el.setAttribute('aria-hidden', 'true');\n        this.$el.setAttribute('aria-modal', 'true');\n        this.$el.setAttribute('tabindex', '-1');\n        if (!this.$el.hasAttribute('role')) {\n            this.$el.setAttribute('role', 'dialog');\n        }\n        document.addEventListener('click', this.handleTriggerClicks, true);\n    }\n    /**\n     * Destroy the current instance (after making sure the dialog has been hidden)\n     * and remove all associated listeners from dialog openers and closers\n     */\n    destroy() {\n        // Dispatch a `destroy` event\n        const destroyEvent = this.fire('destroy');\n        // If the event was prevented, do not continue with the normal behavior\n        if (destroyEvent.defaultPrevented)\n            return this;\n        // Hide the dialog to avoid destroying an open instance\n        this.hide();\n        // Remove the click event delegates for our openers and closers\n        document.removeEventListener('click', this.handleTriggerClicks, true);\n        // Clone and replace the dialog element to prevent memory leaks caused by\n        // event listeners that the author might not have cleaned up.\n        this.$el.replaceWith(this.$el.cloneNode(true));\n        return this;\n    }\n    /**\n     * Show the dialog element, trap the current focus within it, listen for some\n     * specific key presses and fire all registered callbacks for `show` event\n     */\n    show(event) {\n        // If the dialog is already open, abort\n        if (this.shown)\n            return this;\n        // Dispatch a `show` event\n        const showEvent = this.fire('show', event);\n        // If the event was prevented, do not continue with the normal behavior\n        if (showEvent.defaultPrevented)\n            return this;\n        // Keep a reference to the currently focused element to be able to restore\n        // it later\n        this.shown = true;\n        this.$el.removeAttribute('aria-hidden');\n        this.previouslyFocused = getActiveEl();\n        // Due to a long lasting bug in Safari, clicking an interactive element\n        // (like a <button>) does *not* move the focus to that element, which means\n        // `document.activeElement` is whatever element is currently focused (like\n        // an <input>), or the <body> element otherwise. We can work around that\n        // problem by checking whether the focused element is the <body>, and if it,\n        // store the click event target.\n        // See: https://bugs.webkit.org/show_bug.cgi?id=22261\n        if (this.previouslyFocused?.tagName === 'BODY' && event?.target) {\n            this.previouslyFocused = event.target;\n        }\n        // Set the focus to the dialog element\n        // See: https://github.com/KittyGiraudel/a11y-dialog/pull/583\n        if (event?.type === 'focus') {\n            this.maintainFocus();\n        }\n        else {\n            focus(this.$el);\n        }\n        // Bind a focus event listener to the body element to make sure the focus\n        // stays trapped inside the dialog while open, and start listening for some\n        // specific key presses (TAB and ESC)\n        document.body.addEventListener('focus', this.maintainFocus, true);\n        this.$el.addEventListener('keydown', this.bindKeypress, true);\n        return this;\n    }\n    /**\n     * Hide the dialog element, restore the focus to the previously active\n     * element, stop listening for some specific key presses and fire all\n     * registered callbacks for `hide` event\n     */\n    hide(event) {\n        // If the dialog is already closed, abort\n        if (!this.shown)\n            return this;\n        // Dispatch a `hide` event\n        const hideEvent = this.fire('hide', event);\n        // If the event was prevented, do not continue with the normal behavior\n        if (hideEvent.defaultPrevented)\n            return this;\n        this.shown = false;\n        this.$el.setAttribute('aria-hidden', 'true');\n        // Ensure the previously focused element (if any) has a `focus` method\n        // before attempting to call it to account for SVG elements\n        // See: https://github.com/KittyGiraudel/a11y-dialog/issues/108\n        this.previouslyFocused?.focus?.();\n        // Remove the focus event listener to the body element and stop listening\n        // for specific key presses\n        document.body.removeEventListener('focus', this.maintainFocus, true);\n        this.$el.removeEventListener('keydown', this.bindKeypress, true);\n        return this;\n    }\n    /**\n     * Register a new callback for the given event type\n     */\n    on(type, handler, options) {\n        this.$el.addEventListener(type, handler, options);\n        return this;\n    }\n    /**\n     * Unregister an existing callback for the given event type\n     */\n    off(type, handler, options) {\n        this.$el.removeEventListener(type, handler, options);\n        return this;\n    }\n    /**\n     * Dispatch and return a custom event from the DOM element associated with\n     * this dialog; this allows authors to listen for and respond to the events\n     * in their own code\n     */\n    fire(type, event) {\n        const customEvent = new CustomEvent(type, {\n            detail: event,\n            cancelable: true,\n        });\n        this.$el.dispatchEvent(customEvent);\n        return customEvent;\n    }\n    /**\n     * Add a delegated event listener for when elememts that open or close the\n     * dialog are clicked, and call `show` or `hide`, respectively\n     */\n    handleTriggerClicks(event) {\n        // We need to retrieve the click target while accounting for Shadow DOM.\n        // When within a web component, `event.target` is the shadow root (e.g.\n        // `<my-dialog>`), so we need to use `event.composedPath()` to get the click\n        // target\n        // See: https://github.com/KittyGiraudel/a11y-dialog/issues/582\n        const target = event.composedPath()[0];\n        const opener = closest(`[${SCOPE}-show=\"${this.id}\"]`, target);\n        const explicitCloser = closest(`[${SCOPE}-hide=\"${this.id}\"]`, target);\n        const implicitCloser = closest(`[${SCOPE}-hide]`, target) &&\n            closest('[aria-modal=\"true\"]', target) === this.$el;\n        // We use `closest(..)` (instead of `matches(..)`) so that clicking an\n        // element nested within a dialog opener does cause the dialog to open, and\n        // we use our custom `closest(..)` function so that it can cross shadow\n        // boundaries\n        // See: https://github.com/KittyGiraudel/a11y-dialog/issues/712\n        if (opener)\n            this.show(event);\n        if (explicitCloser || implicitCloser)\n            this.hide(event);\n    }\n    /**\n     * Private event handler used when listening to some specific key presses\n     * (namely ESC and TAB)\n     */\n    bindKeypress(event) {\n        // This is an escape hatch in case there are nested open dialogs, so that\n        // only the top most dialog gets interacted with (`closest` is basically\n        // `Element.prototype.closest()` accounting for Shadow DOM subtrees)\n        if (closest('[aria-modal=\"true\"]', getActiveEl()) !== this.$el) {\n            return;\n        }\n        let hasOpenPopover = false;\n        try {\n            hasOpenPopover = !!this.$el.querySelector('[popover]:not([popover=\"manual\"]):popover-open');\n        }\n        catch {\n            // Run that DOM query in a try/catch because not all browsers support the\n            // `:popover-open` selector, which would cause the whole expression to\n            // fail\n            // See: https://caniuse.com/mdn-css_selectors_popover-open\n            // See: https://github.com/KittyGiraudel/a11y-dialog/pull/578#discussion_r1343215149\n        }\n        // If the dialog is shown and the ESC key is pressed, prevent any further\n        // effects from the ESC key and hide the dialog, unless:\n        // - its role is `alertdialog`, which means it should be modal\n        // - or it contains an open popover, in which case ESC should close it\n        if (event.key === 'Escape' &&\n            this.$el.getAttribute('role') !== 'alertdialog' &&\n            !hasOpenPopover) {\n            event.preventDefault();\n            this.hide(event);\n        }\n        // If the dialog is shown and the TAB key is pressed, make sure the focus\n        // stays trapped within the dialog element\n        if (event.key === 'Tab') {\n            trapTabKey(this.$el, event);\n        }\n    }\n    /**\n     * If the dialog is shown and the focus is not within a dialog element (either\n     * this one or another one in case of nested dialogs) or an element with the\n     * ignore attribute, move it back to the dialog container\n     * See: https://github.com/KittyGiraudel/a11y-dialog/issues/177\n     */\n    maintainFocus() {\n        // We use `getActiveEl()` and not `event.target` here because the latter can\n        // be a shadow root. This can happen when having a focusable element after\n        // slotted content: tabbing out of it causes this focus listener to trigger\n        // with the shadow root as a target event. In such a case, the focus would\n        // be incorrectly moved to the dialog, which shouldn’t happen. Getting the\n        // active element (while accounting for Shadow DOM) avoids that problem.\n        // See: https://github.com/KittyGiraudel/a11y-dialog/issues/778\n        const target = getActiveEl();\n        if (!closest(`[aria-modal=\"true\"], [${SCOPE}-ignore-focus-trap]`, target)) {\n            focus(this.$el);\n        }\n    }\n}\n\nfunction instantiateDialogs() {\n    for (const el of document.querySelectorAll('[data-a11y-dialog]')) {\n        new A11yDialog(el);\n    }\n}\nif (typeof document !== 'undefined') {\n    if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', instantiateDialogs);\n    }\n    else {\n        instantiateDialogs();\n    }\n}\n\nexport { A11yDialog as default };\n","/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n","// get successful control from form and assemble into object\n// http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2\n\n// types which indicate a submit action and are not successful controls\n// these will be ignored\nvar k_r_submitter = /^(?:submit|button|image|reset|file)$/i;\n\n// node names which could be successful controls\nvar k_r_success_contrls = /^(?:input|select|textarea|keygen)/i;\n\n// Matches bracket notation.\nvar brackets = /(\\[[^\\[\\]]*\\])/g;\n\n// serializes form fields\n// @param form MUST be an HTMLForm element\n// @param options is an optional argument to configure the serialization. Default output\n// with no options specified is a url encoded string\n//    - hash: [true | false] Configure the output type. If true, the output will\n//    be a js object.\n//    - serializer: [function] Optional serializer function to override the default one.\n//    The function takes 3 arguments (result, key, value) and should return new result\n//    hash and url encoded str serializers are provided with this module\n//    - disabled: [true | false]. If true serialize disabled fields.\n//    - empty: [true | false]. If true serialize empty fields\nfunction serialize(form, options) {\n    if (typeof options != 'object') {\n        options = { hash: !!options };\n    }\n    else if (options.hash === undefined) {\n        options.hash = true;\n    }\n\n    var result = (options.hash) ? {} : '';\n    var serializer = options.serializer || ((options.hash) ? hash_serializer : str_serialize);\n\n    var elements = form && form.elements ? form.elements : [];\n\n    //Object store each radio and set if it's empty or not\n    var radio_store = Object.create(null);\n\n    for (var i=0 ; i<elements.length ; ++i) {\n        var element = elements[i];\n\n        // ingore disabled fields\n        if ((!options.disabled && element.disabled) || !element.name) {\n            continue;\n        }\n        // ignore anyhting that is not considered a success field\n        if (!k_r_success_contrls.test(element.nodeName) ||\n            k_r_submitter.test(element.type)) {\n            continue;\n        }\n\n        var key = element.name;\n        var val = element.value;\n\n        // we can't just use element.value for checkboxes cause some browsers lie to us\n        // they say \"on\" for value when the box isn't checked\n        if ((element.type === 'checkbox' || element.type === 'radio') && !element.checked) {\n            val = undefined;\n        }\n\n        // If we want empty elements\n        if (options.empty) {\n            // for checkbox\n            if (element.type === 'checkbox' && !element.checked) {\n                val = '';\n            }\n\n            // for radio\n            if (element.type === 'radio') {\n                if (!radio_store[element.name] && !element.checked) {\n                    radio_store[element.name] = false;\n                }\n                else if (element.checked) {\n                    radio_store[element.name] = true;\n                }\n            }\n\n            // if options empty is true, continue only if its radio\n            if (val == undefined && element.type == 'radio') {\n                continue;\n            }\n        }\n        else {\n            // value-less fields are ignored unless options.empty is true\n            if (!val) {\n                continue;\n            }\n        }\n\n        // multi select boxes\n        if (element.type === 'select-multiple') {\n            val = [];\n\n            var selectOptions = element.options;\n            var isSelectedOptions = false;\n            for (var j=0 ; j<selectOptions.length ; ++j) {\n                var option = selectOptions[j];\n                var allowedEmpty = options.empty && !option.value;\n                var hasValue = (option.value || allowedEmpty);\n                if (option.selected && hasValue) {\n                    isSelectedOptions = true;\n\n                    // If using a hash serializer be sure to add the\n                    // correct notation for an array in the multi-select\n                    // context. Here the name attribute on the select element\n                    // might be missing the trailing bracket pair. Both names\n                    // \"foo\" and \"foo[]\" should be arrays.\n                    if (options.hash && key.slice(key.length - 2) !== '[]') {\n                        result = serializer(result, key + '[]', option.value);\n                    }\n                    else {\n                        result = serializer(result, key, option.value);\n                    }\n                }\n            }\n\n            // Serialize if no selected options and options.empty is true\n            if (!isSelectedOptions && options.empty) {\n                result = serializer(result, key, '');\n            }\n\n            continue;\n        }\n\n        result = serializer(result, key, val);\n    }\n\n    // Check for all empty radio buttons and serialize them with key=\"\"\n    if (options.empty) {\n        for (var key in radio_store) {\n            if (!radio_store[key]) {\n                result = serializer(result, key, '');\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction parse_keys(string) {\n    var keys = [];\n    var prefix = /^([^\\[\\]]*)/;\n    var children = new RegExp(brackets);\n    var match = prefix.exec(string);\n\n    if (match[1]) {\n        keys.push(match[1]);\n    }\n\n    while ((match = children.exec(string)) !== null) {\n        keys.push(match[1]);\n    }\n\n    return keys;\n}\n\nfunction hash_assign(result, keys, value) {\n    if (keys.length === 0) {\n        result = value;\n        return result;\n    }\n\n    var key = keys.shift();\n    var between = key.match(/^\\[(.+?)\\]$/);\n\n    if (key === '[]') {\n        result = result || [];\n\n        if (Array.isArray(result)) {\n            result.push(hash_assign(null, keys, value));\n        }\n        else {\n            // This might be the result of bad name attributes like \"[][foo]\",\n            // in this case the original `result` object will already be\n            // assigned to an object literal. Rather than coerce the object to\n            // an array, or cause an exception the attribute \"_values\" is\n            // assigned as an array.\n            result._values = result._values || [];\n            result._values.push(hash_assign(null, keys, value));\n        }\n\n        return result;\n    }\n\n    // Key is an attribute name and can be assigned directly.\n    if (!between) {\n        result[key] = hash_assign(result[key], keys, value);\n    }\n    else {\n        var string = between[1];\n        // +var converts the variable into a number\n        // better than parseInt because it doesn't truncate away trailing\n        // letters and actually fails if whole thing is not a number\n        var index = +string;\n\n        // If the characters between the brackets is not a number it is an\n        // attribute name and can be assigned directly.\n        if (isNaN(index)) {\n            result = result || {};\n            result[string] = hash_assign(result[string], keys, value);\n        }\n        else {\n            result = result || [];\n            result[index] = hash_assign(result[index], keys, value);\n        }\n    }\n\n    return result;\n}\n\n// Object/hash encoding serializer.\nfunction hash_serializer(result, key, value) {\n    var matches = key.match(brackets);\n\n    // Has brackets? Use the recursive assignment function to walk the keys,\n    // construct any missing objects in the result tree and make the assignment\n    // at the end of the chain.\n    if (matches) {\n        var keys = parse_keys(key);\n        hash_assign(result, keys, value);\n    }\n    else {\n        // Non bracket notation can make assignments directly.\n        var existing = result[key];\n\n        // If the value has been assigned already (for instance when a radio and\n        // a checkbox have the same name attribute) convert the previous value\n        // into an array before pushing into it.\n        //\n        // NOTE: If this requirement were removed all hash creation and\n        // assignment could go through `hash_assign`.\n        if (existing) {\n            if (!Array.isArray(existing)) {\n                result[key] = [ existing ];\n            }\n\n            result[key].push(value);\n        }\n        else {\n            result[key] = value;\n        }\n    }\n\n    return result;\n}\n\n// urlform encoding serializer\nfunction str_serialize(result, key, value) {\n    // encode newlines as \\r\\n cause the html spec says so\n    value = value.replace(/(\\r)?\\n/g, '\\r\\n');\n    value = encodeURIComponent(value);\n\n    // spaces should be '+' rather than '%20'.\n    value = value.replace(/%20/g, '+');\n    return result + (result ? '&' : '') + encodeURIComponent(key) + '=' + value;\n}\n\nmodule.exports = serialize;\n","import A11yDialog from \"a11y-dialog\";\nimport escapeHtml from \"escape-html\";\nimport serialize from \"form-serialize\";\n\nconst defaults = {};\nconst options = {\n  ...defaults,\n  ...(window.nrelContactOptions || {}),\n};\n\nif (!options.apiKey) {\n  alert(\"nrelContactOptions.apiKey must be set\");\n}\n\nconst modalEl = document.getElementById(\"alert_modal\");\nconst modalMessageEl = modalEl.querySelector(\"#alert_modal_message\");\nconst modal = new A11yDialog(modalEl);\n\nconst formEl = document.getElementById(\"nrel_contact_form\");\nformEl.addEventListener(\"submit\", (event) => {\n  event.preventDefault();\n\n  if (!formEl.checkValidity()) {\n    formEl.classList.add(\"was-validated\");\n    return false;\n  }\n\n  const submitButtonEl = formEl.querySelector(\"button[type=submit]\");\n  const submitButtonOrig = submitButtonEl.innerHTML;\n  setTimeout(() => {\n    submitButtonEl.disabled = true;\n    submitButtonEl.innerText = \"Sending...\";\n  }, 0);\n\n  const hostname = window.location.hostname;\n  const apiHost = (hostname === 'developer.nrel.gov') ? 'developer.nrel.gov' : 'devstage.nrel.gov';\n\n  return fetch(`https://${apiHost}/api/contactor/v1.json?` + new URLSearchParams({\n    api_key: options.apiKey,\n  }), {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(serialize(formEl, { hash: true })),\n  })\n    .then((response) => {\n      const contentType = response.headers.get(\"Content-Type\");\n      if (!contentType || !contentType.includes(\"application/json\")) {\n        throw new Error(\"Response is not JSON\");\n      }\n\n      return response.json().then((data) => ({\n        response,\n        data,\n      }));\n    })\n    .then(({ response, data }) => {\n      if (!response.ok) {\n        throw { responseData: data };\n      }\n\n      formEl.reset();\n\n      modalMessageEl.innerText =\n        \"Thanks for sending your message. We'll be in touch.\";\n      modal.show();\n    })\n    .catch((error) => {\n      const messages = [];\n      let messageStr = \"\";\n      try {\n        if (error?.responseData?.errors) {\n          for (let i = 0; i < error.responseData.errors.length; i += 1) {\n            const err = error.responseData.errors[i];\n            if (err.full_message || err.message) {\n              messages.push(escapeHtml(err.full_message || err.message));\n            }\n          }\n        }\n\n        if (error?.responseData?.error?.message) {\n          messages.push(escapeHtml(error.responseData.error.message));\n        }\n\n        if (messages.length > 0) {\n          messageStr = `<br><ul><li>${messages.join(\"</li><li>\")}</li></ul>`;\n        } else {\n          console.error(error);\n        }\n      } catch (e) {\n        console.error(e);\n      }\n\n      modalMessageEl.innerHTML = `Sending your message unexpectedly failed.${messageStr}<br>Please try again or <a href=\"${escapeHtml(\n        options.issuesUrl,\n      )}\">file an issue</a> for assistance.`;\n      modal.show();\n    })\n    .finally(() => {\n      submitButtonEl.disabled = false;\n      submitButtonEl.innerHTML = submitButtonOrig;\n    });\n});\n"],"names":["not","focusableSelectors","focus","el","getFocusableEdges","firstEl","findFocusableEl","lastEl","forward","isFocusable","canHaveFocusableChildren","next","getNextChildEl","focusableEl","getNextSiblingEl","assignedElements","assignedElement","isHidden","_a","getActiveEl","root","activeEl","trapTabKey","event","firstFocusableEl","lastFocusableEl","closest","selector","base","from","slot","findAssignedSlot","node","SCOPE","A11yDialog","element","__publicField","_b","type","handler","options","customEvent","target","opener","explicitCloser","implicitCloser","hasOpenPopover","instantiateDialogs","matchHtmlRegExp","escapeHtml_1","escapeHtml","string","str","match","escape","html","index","lastIndex","k_r_submitter","k_r_success_contrls","brackets","serialize","form","result","serializer","hash_serializer","str_serialize","elements","radio_store","i","key","val","selectOptions","isSelectedOptions","j","option","allowedEmpty","hasValue","parse_keys","keys","prefix","children","hash_assign","value","between","matches","existing","formSerialize","defaults","modalEl","modalMessageEl","modal","formEl","submitButtonEl","submitButtonOrig","apiHost","response","contentType","data","error","messages","messageStr","err","_c","e"],"mappings":"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","x_google_ignoreList":[0,1,2]}